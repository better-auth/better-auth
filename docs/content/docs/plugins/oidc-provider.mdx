---
title: OIDC Provider
description: Open ID Connect plugin for Better Auth that allows you to have your own OIDC provider.
---

The **OIDC Provider Plugin** enables you to build and manage your own OpenID Connect (OIDC) provider, granting full control over user authentication without relying on third-party services like Okta or Azure AD. It also allows other services to authenticate users through your OIDC provider.

**Key Features**:

- **Dynamic Client Registration**: Allow clients to register dynamically with your OIDC provider.
- **Authorization Code Flow**: Support the Authorization Code Flow.
- **Refresh Tokens**: Issue refresh tokens and handle access token renewal using the `refresh_token` grant.
- **Client Credentials Flow**: Support for client credentials flow for both public and confidential clients.
- **OAuth Consent**: Implements OAuth consent screens for user authorization.
- **UserInfo Endpoint**: Provide a UserInfo endpoint for clients to retrieve user details.

**Required Plugins**

- **(JWT)[./jwt]** Manages signed tokens

By default, the OIDC Provider follows (oAuth 2.1)[https://datatracker.ietf.org/doc/draft-ietf-oauth-v2-1/]. While the OIDC spec currently usage states oAuth 2.0 and oAuth 2.1 in current draft, this plugin SHALL be hardened only with oAuth 2.1 principles including:

- Requirement of PKCE for Authorization Code Grant
- Redirect URI are compared with exact string matching
- Removal of Implicit Grant
- Removal of Resource Owner Password Grant
- Removal of bearer token in query string of URIs
- Refresh tokens are one-time use (for all client types by default)
- Client Credentials support through body credentials

**NOTE:** oAuth 2.1 only hardens the Authorization Server security principles, so oAuth 2.0 compatable clients should still work. The server just fails, instead of authorizes, depreciated methods.

## Installation

<Steps>
    <Step>
        ### Mount the Plugin

        Add the OIDC plugin to your auth config. See [OIDC Configuration](#oidc-configuration) on how to configure the plugin.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth";
        import { oidcProvider } from "better-auth/plugins";

        const auth = betterAuth({
            plugins: [
              jwt({
					      usesOidcProviderPlugin: true,
				      }),
              oidcProvider({
                loginPage: "/sign-in", // path to the login page (ie prompt='login')
                consentPage: "/consent" // path to a consent page (ie prompt='consent')
                // ...other options
              })
            ]
        })
        ```
    </Step>

    <Step>
        ### Migrate the Database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```bash
            npx @better-auth/cli migrate
            ```
            </Tab>
            <Tab value="generate">
            ```bash
            npx @better-auth/cli generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>

    <Step>
        ### Add the Client Plugin

        Add the OIDC client plugin to your auth client config.

        ```ts
        import { createAuthClient } from "better-auth/client";
        import { oidcClient } from "better-auth/client/plugins"
        const authClient = createAuthClient({
            plugins: [oidcClient({
                // Your OIDC configuration
            })]
        })
        ```
    </Step>
</Steps>

## Usage

Once installed, you can utilize the OIDC Provider to manage authentication flows within your application.

### Register a New Client

To register a new OIDC client, use the `oauth2.register` method.

<Endpoint path="/oauth2/register" method="POST" />

```ts title="client.ts"
const application = await client.oauth2.register({
    client_name: "My Client",
    redirect_uris: ["https://client.example.com/callback"],
});
```

Once the application is created, you will receive a `client_id` and `client_secret` that you can display to the user.

This Endpoint supports [RFC7591](https://datatracker.ietf.org/doc/html/rfc7591) compliant client registration.

### UserInfo Endpoint

The OIDC Provider includes a UserInfo endpoint that allows clients to retrieve information about the authenticated user. This endpoint is available at `/oauth2/userinfo` and requires a valid access token.

<Endpoint path="/oauth2/userinfo" method="GET" />

```ts title="client-app.ts"
// Example of how a client would use the UserInfo endpoint
const response = await fetch('https://your-domain.com/api/auth/oauth2/userinfo', {
  headers: {
    'Authorization': 'Bearer ACCESS_TOKEN'
  }
});

const userInfo = await response.json();
// userInfo contains user details based on the scopes granted
```

The UserInfo endpoint returns different claims based on the scopes that were granted during authorization:

- With `openid` scope: Returns the user's ID (`sub` claim)
- With `profile` scope: Returns name, picture, given_name, family_name
- With `email` scope: Returns email and email_verified

The `getAdditionalUserInfoClaim` function receives the user object and the requested scopes array, allowing you to conditionally include claims based on the scopes granted during authorization. These additional claims will be included in both the UserInfo endpoint response and the ID token.

### Consent Screen

When a user is redirected to the OIDC provider for authentication, they may be prompted to authorize the application to access their data. This is known as the consent screen.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    plugins: [oidcProvider({
        consentPage: "/path/to/consent/page"
    })]
})
```

The plugin will redirect the user to the specified path with a `client_id` and `scope` query parameter. You can use this information to display a custom consent screen. Once the user consents, you can call `oauth2.consent` to complete the authorization.

<Endpoint path="/oauth2/consent" method="POST" />

```ts title="server.ts"
const res = await client.oauth2.consent({
	accept: true, // or false to deny
});
```

The `client_id` and other necessary information are stored in a browser cookie, so you don't need to pass them in the request. If they don't exist in the cookie, the consent method will return an error.

### Handling Login

When a user is redirected to the OIDC provider for authentication, if they are not already logged in, they will be redirected to the login page. You can customize the login page by providing a `loginPage` option during initialization.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    plugins: [oidcProvider({
        loginPage: "/sign-in"
    })]
})
```

You don't need to handle anything from your side; when a new session is created, the plugin will handle continuing the authorization flow.

## Configuration

### Scopes

Scopes allow clients specific access to specific resources.
By default, we support the following scopes are supported:

- `openid`: Returns the user's ID (`sub` claim).
- `profile`: Returns name, picture, given_name, family_name
- `email`: Returns email and email_verified
- `offline_access`: Returns a refresh token

The scopes configuration can contain as many or as few scopes as you wish! Note that `openid` is required to be considered an OIDC server, otherwise this is a standard OAuth 2.1 server. All supported scopes must be in this array.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { oidcProvider } from "better-auth/plugins";

export const auth = betterAuth({
    plugins: [oidcProvider({
        scopes: [ "openid", "profile", "offline_access", "read:post", "write:post" ],
    })]
})
```

### Claims

Claims are fields defined in your access and id tokens. You can add more claims using the `customClaims`.

By internally, we support the following claims are supported: ["sub", "iss", "aud", "exp", "nbf", "iat", "jti", "sid", "scope", "azp"].

The claims configuration can only be appended to the internal supported claims. Claims should be namespaced when possible to avoid potential future conflicts.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { oidcProvider } from "better-auth/plugins";

export const auth = betterAuth({
    plugins: [oidcProvider({
        customClaims: [ "locale", "https://example.com/roles" ],
        // Attach claims to id tokens
        customIdTokenClaims: (_user: User, _scopes: string[]) => {
          return {
            locale: "en-GB",
          }
        },
        // Attach claims to access tokens
        customJwtClaims: (_user: User, _scopes: string[]) => {
          return {
            "https://example.com/roles": ["admin", "editor"],
          }
        },
        // Additional user info claims
        getAdditionalUserInfoClaim: (_user: User, _scopes: string[]) => {
          return {
            locale: "en-GB",
            "https://example.com/roles": ["admin", "editor"],
          }
        },
    })]
})
```

### Well-known Configuration

You may wish to hide specific scopes and claims from your well-known configuration. To do so, use the `advertisedMetadata` setting to advertise different scope and claims. This MUST be in your scopes list otherwise the plugin will fail.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { oidcProvider } from "better-auth/plugins";

export const auth = betterAuth({
    plugins: [oidcProvider({
        advertisedMetadata: {
            scopes_supported: [ "openid", "profile", "offline_access" ],
            claims_supported: [ "sub", "iss", "aud", "exp", "nbf", "iat", "jti", "sid", "scope", "azp" ],
        }
    })]
})
```

### JWT

This plugin uses the JWT plugin to issue and sign JWT tokens. It exposes the `/jwks` endpoint to provide the public keys for verification.

You must set `usesOidcProviderPlugin` to ensure the JWT plugin is OIDC compatable. The JWT plugin must also be registered before OIDC plugin.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { jwt } from "better-auth/plugins";

export const auth = betterAuth({
    plugins: [jwt({
        usesOidcProviderPlugin: true,
        // ...other options
      }),
      oidcProvider({
        loginPage: "/sign-in", // path to the login page
        consentPage: "/consent" // path to a consent page
        // ...other options
      }),
    ]
})
```

### Dynamic Client Registration

If you want to allow clients to register dynamically, you can enable this feature by setting the `allowDynamicClientRegistration` option to `true`.

```ts title="auth.ts"
const auth = betterAuth({
    plugins: [oidcProvider({
        allowDynamicClientRegistration: true,
    })]
})
```

If you wish to also allow clients to register clients without authentication, such as for MCP, you can enable this feature by setting the `allowUnauthenticatedClientRegistration` option to `true`.

```ts title="auth.ts"
const auth = betterAuth({
    plugins: [oidcProvider({
        allowDynamicClientRegistration: true,
        allowUnauthenticatedClientRegistration: true,
    })]
})
```

#### Dynamic Client Registration Scopes

To set a list of default scopes for newly registered clients when scopes parameter is not sent, set the `clientRegistrationDefaultScopes` field. All scopes must be defined in `scopes`.

```ts title="auth.ts"
const auth = betterAuth({
    plugins: [oidcProvider({
        scopes: ["reader", "editor"],
        clientRegistrationDefaultScopes: ["reader"],
    })]
})
```

To also set a list of allowed scopes for newly registered clients when scopes parameter is not sent, set the `clientRegistrationAllowedScopes` field. These are **in addition** to the `clientRegistrationDefaultScopes`. All scopes must be defined in `scopes`.

```ts title="auth.ts"
const auth = betterAuth({
    plugins: [oidcProvider({
        scopes: ["reader", "editor"],
        clientRegistrationDefaultScopes: ["reader"],
        clientRegistrationAllowedScopes: ["editor"],
    })]
})
```

### Refresh Token Customization

You can choose to format your session tokens in a different string format using the `encodeRefreshToken` and `decodeRefreshToken` functions.

These functions allow you to add additional functionality on the refresh token itself such as refresh token encryption or storage for session replay attacks.

If defined, both `encodeRefreshToken` and `decodeRefreshToken` functions. must be defined.

Example with change in refresh token format and backwards compatablity with v0 token-only format:

```ts title="auth.ts"
const auth = betterAuth({
    plugins: [oidcProvider({
        encodeRefreshToken: (token, session) {
          const res = session ? `1.${token}.${session}` : token;
          return res;
        },
        decodeRefreshToken: (token) {
          const tokenSplit = token.split('.');
          if (tokenSplit.length === 3 && tokenSplit.at(0) === '1') {
            return {
              token: tokenSplit.at(1),
              sessionId: tokenSplit.at(2),
            };
          }
          return { token };
        },
    })]
})
```

Pseudocode for a token encryption:

```ts title="auth.ts"
import { CompactEncrypt, compactDecrypt } from 'jose'

const secret = "SOME_SECRET_OR_KEY"
const alg = "A256KW"
consts enc = "A256GCM"

const auth = betterAuth({
    plugins: [oidcProvider({
        encodeRefreshToken: (token, session) {
          const value = JSON.stringify({
            sessionId: session.id,
            token,
          });
          const jwe = await new CompactEncrypt(Buffer.from(value))
            .setProtectedHeader({ alg, enc })
            .encrypt(secret);
          return jwe;
        },
        decodeRefreshToken: (token) {
          const { plaintext } = await compactDecrypt(token, secret);
          const payload = new TextDecoder().decode(plaintext);
          return JSON.parse(payload);
        },
    })]
})
```

## Schema

The OIDC Provider plugin adds the following tables to the database:

### OAuth Application

Table Name: `oauthClient`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Database ID of the OAuth client",
      isPrimaryKey: true
    },
    {
      name: "clientId",
      type: "string",
      isForeignKey: true,
      references: { model: "oauthClient", field: "clientId" }
      description: "Unique identifier for each OAuth client",
      isPrimaryKey: true
    },
    { 
      name: "clientSecret",
      type: "string",
      description: "Secret key for the OAuth client",
      isRequired: false
    },
    { 
      name: "disabled",
      type: "boolean",
      description: "Indicates if the client is disabled",
      isRequired: true
    },
    {
      name: "scope",
      type: "string",
      description: "Space-separated list of scopes",
      isRequired: true
    },
    { 
      name: "userId",
      type: "string",
      description: "ID of the user who owns the client. (optional)",
      isOptional: true,
      isForeignKey: true,
      references: { model: "user", field: "id" }
    },
    { 
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the OAuth client was created" 
      isOptional: true
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the OAuth client was last updated"
    }
    { 
      name: "name", 
      type: "string", 
      description: "Name of the OAuth client",
      isOptional: true
    },
    { 
      name: "uri", 
      type: "string", 
      description: "Client homepage",
      isOptional: true
    },
    {
      name: "icon", 
      type: "string", 
      description: "Logo of the client",
      isOptional: true,
    },
    {
      name: "contacts", 
      type: "string", 
      description: "Comma-separated list of support contacts (likely email)",
      isOptional: true
    },
    {
      name: "tos", 
      type: "string", 
      description: "Terms of Service uri of the client",
      isOptional: true
    },
    {
      name: "policy", 
      type: "string", 
      description: "policy uri of the client",
      isOptional: true
    },
    {
      name: "softwareId", 
      type: "string", 
      description: "Client defined software id",
      isOptional: true
    },
    {
      name: "softwareVersion", 
      type: "string", 
      description: "Version of the software id",
      isOptional: true
    },
    {
      name: "softwareStatement", 
      type: "string", 
      description: "Jwt signed statement of the software",
      isOptional: true
    },
    {
      name: "redirectURLs", 
      type: "string", 
      description: "Comma-separated list of redirect URLs",
      isRequired: true
    },
    {
      name: "tokenEndpointAuthMethod", 
      type: "string", 
      description: "Comma-separated token endpoint auth methods allowed",
      isOptional: true
    },
    {
      name: "grantTypes", 
      type: "string", 
      description: "Comma-separated grant types allowed",
      isOptional: true
    },
    {
      name: "responseTypes", 
      type: "string", 
      description: "Comma-separated response types allowed",
      isOptional: true
    },
    {
      name: "public", 
      type: "string",
      description: "Type of OAuth client (e.g., web, mobile)",
      isRequired: true
    },
    {
      name: "type", 
      type: "string",
      description: "Type of OAuth client (e.g., web, mobile)",
      isOptional: true
    },
    {
      name: "metadata", 
      type: "string",
      description: "Additional metadata for the OAuth client",
      isOptional: true
    },
  ]}
/>

### Session

Merges with `session` schema. Additional fields:

<DatabaseTable
  fields={[
    { 
      name: "token", 
      type: "string", 
      description: "Access token issued to the client",
    },
    { 
      name: "clientId", 
      type: "string", 
      description: "ID of the OAuth client",
      isForeignKey: true,
      references: { model: "oauthClient", field: "clientId" }
    },
    { 
      name: "scopes", 
      type: "string", 
      description: "Comma-separated list of scopes granted",
      isRequired: true
    },
  ]}
/>

### OAuth Consent

Table Name: `oauthConsent`

<DatabaseTable
  fields={[
    { 
      name: "id", 
      type: "string", 
      description: "Database ID of the consent",
      isPrimaryKey: true
    },
    { 
      name: "userId", 
      type: "string", 
      description: "ID of the user who gave consent",
      isForeignKey: true,
      references: { model: "user", field: "id" }
    },
    { 
      name: "clientId", 
      type: "string", 
      description: "ID of the OAuth client",
      isForeignKey: true,
      references: { model: "oauthClient", field: "clientId" }
    },
    { 
      name: "scopes", 
      type: "string", 
      description: "Comma-separated list of scopes consented to",
      isRequired: true
    },
    { 
      name: "consentGiven", 
      type: "boolean", 
      description: "Indicates if consent was given",
      isRequired: true
    },
    { 
      name: "createdAt", 
      type: "Date", 
      description: "Timestamp of when the consent was given" 
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the consent was last updated"
    }
  ]}
/>

## Options

### Required

**loginPage** `string` - The URL to the login page. This is used if the client requests the `login`
prompt.

**consentPage** `string` - A URL to the consent page where the user will be redirected if the client
requests consent.

After the user consents, they should be redirected by the client to the `redirect_uri` with the authorization code.

When the server redirects the user to the consent page, it will include the
following query parameters:

- `client_id` - The ID of the client.
- `scope` - The requested scopes.
- `code` - The authorization code.

once the user consents, you need to call the `/oauth2/consent` endpoint
with the code and `accept: true` to complete the authorization. Which will
then return the client to the `redirect_uri` with the authorization code.

### Optional

**accessTokenExpiresIn**: `number` @default 10 minutes - The amount of time in seconds that the access token is valid for. 10 min is recommended by the [OIDC spec](https://openid.net/specs/oauth-v2-jarm.html#section-2.1-2.3.1)

**m2mAccessTokenExpiresIn** `number` @default 1 hour - The amount of time in seconds that a client credentials grant access token is valid for.

**idTokenExpiresIn** `number` @default 10 hours - The amount of time in seconds that id token is valid for.

**refreshTokenExpiresIn** `number` @default 30 days - The amount of time in seconds that the refresh token is valid for.

**codeExpiresIn** `number` @default 10 minutes - The amount of time in seconds that the authorization code is valid for.

**allowUnauthenticatedClientRegistration** `boolean` @default false - Allow dynamic client registration.

**allowDynamicClientRegistration** `boolean` @default false - Allow dynamic client registration.

**clientRegistrationDefaultScopes** `string[]` - List of scopes for newly registered clients if not requested

**clientRegistrationAllowedScopes** `string[]` @default `clientRegistrationDefaultScopes` - List of scopes for allowed clients in addition to those listed in the default scope. Finalized allowed list is the union of `clientRegistrationDefaultScopes` and this list. If both `clientRegistrationDefaultScopes` and this are undefined, only scopes listed in the `scopes` option are allowed.

**clientCredentialGrantDefaultScopes** `string[]` - List of scopes a newly registered client can have. Leave undefined to throw error if no scope was sent

**scopes** `string[]` @default ["openid", "profile", "email", "offline_access"] - The scopes that the client is allowed to request. Must contain "openid" to be considered an [OIDC server](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims), otherwise it is just an OAuth server.

**generateClientId** `() => string` - Custom function to generate a client ID.

**generateClientSecret** `() => string` - Custom function to generate a client secret.

**customClaims** `string[]` - List of all additional claims returned from customIdTokenClaims and customJwtClaims. Must be defined when using customIdTokenClaims or customJwtClaims

**getAdditionalUserInfoClaim** `(user: User & Record<string, any>, scopes: string[]) => Awaitable<Record<string, any>>` - Get the additional user info claims. This applies only to the OIDC `userinfo` endpoint.

**customIdTokenClaims** `(user: User & Record<string, any>, scopes: string[]) => Awaitable<Record<string, any>>` - Custom claims attached to id tokens. To remain OIDC compliant, claims should be namespaced with a URI. For example, a site example.com should namespace roles at https://example.com/roles.

**customJwtClaims** `(user: User & Record<string, any>, scopes: string[]) => Awaitable<Record<string, any>>` - Custom claims attached to access tokens.

**encodeRefreshToken** `(token: string, session?: Omit<Session, 'token'> & { token?: string }) => Awaitable<string>;` - Custom session token formatter. You can choose to perform additional functionality such as refresh token encryption or store the raw token for session replay attacks. Must be defined when using decodeRefreshToken.

**decodeRefreshToken** `(token: string) => Awaitable<{ sessionId?: string, token: string }>;` - Decodes a custom session token format. If you changed the format after production deployment, ensure that the prior version can still be decoded. Must be defined when using encodeRefreshToken.

#### Advertised Metadata

Overwrite specific /.well-known/openid-configuration values so they are not available publically. This may be important if not all clients need specific scopes.

NOTE: this does not prevent the system from issuing these scopes and returning those claims (use `scopes` and `customClaims` instead).

**scopes_supported** `string[]` - scopes_supported field for openid configuration. All values must be found in the scope field.

**claims_supported** `string[]` - claims_supported field for openid configuration. All values must be found in the customizedClaims field or be an internally supported claim. Internally supported claims: `["sub", "iss", "aud", "exp", "nbf", "iat", "jti", "sid", "scope", "azp"]`
