---
title: MCP
description: MCP provider plugin for Better Auth
---

`OAuth` `MCP`

The **MCP** plugin adds resource server functionality to your API by utilizing the same OAuth2.1 server used in the OIDC plugin.

**Key Features**:

- Set specific scopes and claims for each API
- OAuth2.1 server with OIDC compatiblity (with "openid" scope)

**Required Plugins**

- **(OIDC)[./oidc-provider]** Sets up the OAuth2.1 server with OIDC compatibility
- **(JWT)[./jwt]** Manages signed tokens. We do not yet cover the case without the Jwt plugin (ie opaque access tokens).

## Installation

<Steps>
    <Step>
        ### Add the Plugin

        Add the MCP plugin to your auth configuration and specify the login page path.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth";
        import { mcp, oidc, jwt } from "better-auth/plugins";

        export const auth = betterAuth({
            plugins: [
                jwt({
                    usesOidcProviderPlugin: true,
                }),
                oidcProvider({
                    loginPage: "/sign-in",
                    consentPage: "/consent",
                }),
                mcp(),
            ],
        });
        ```
        <Callout>
            This doesn't have a client plugin, so you don't need to make any changes to your authClient.
        </Callout>
    </Step>

    <Step>
        ### Generate Schema

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```bash
            npx @better-auth/cli migrate
            ```
            </Tab>
            <Tab value="generate">
            ```bash
            npx @better-auth/cli generate
            ```
            </Tab>
        </Tabs>
        This plugin does not have a schema but the [OIDC](./oidc-provider#schema) and [JWT](./jwt#schema) plugins do.
    </Step>
</Steps>

## Usage

### OAuth Discovery Metadata

Add a route to expose OAuth metadata for MCP clients:

```ts title=".well-known/oauth-authorization-server/route.ts"
import { oAuthDiscoveryMetadata } from "better-auth/plugins";
import { auth } from "../../../lib/auth";

export const GET = oAuthDiscoveryMetadata(auth);
```

### MCP Wrapper

If you have an endpoint that can be wrapped by a request handler
You can use the helper function `withMcpAuth` to verify the session token and handle unauthenticated calls automatically.

```ts title="api/echo/route.ts"
import { auth } from "@/lib/auth";
import { createMcpHandler } from "@vercel/mcp-adapter";
import { withMcpAuth } from "better-auth/plugins";
import { z } from "zod";

interface AuthenticatedRequest extends Request {
  context: {
    jwt: { // JWTPayload from 'jose' package
      sub?: string;
    };
  };
}

export const GET = withMcpAuth(auth, (req: Request) => {
	const sub = (req as AuthenticatedRequest).context.jwt.sub
	return createMcpHandler(
		(server) => {
			server.tool(
				"echo",
				"Echo a message",
				{ message: z.string() },
				async ({ message }) => {
					return {
						content: [{
							type: "text",
							text: `Sub ${sub} says: ${message}`,
						}],
					};
				},
			);
		},
		{
			capabilities: {
				tools: {
					echo: {
						description: "Echo a message",
					},
				},
			},
		},
		{
			redisUrl: process.env.REDIS_URL,
			basePath: "/api",
			verboseLogs: true,
			maxDuration: 60,
		},
	)(req);
});
```

## Advanced

### Checker Function

We provide a generalized checker function as an alternative to `withMcpAuth` to check for an access token's validity.

This function throws an error if not authenticated and **MUST** return the `www-authenticate` header manually. You can use the helper function `handleMcpErrors` to perform this automatically.

```ts
import { auth } from "@/lib/auth"; // Location of BetterAuth options
import { checkMcp, handleMcpErrors } from "better-auth/plugins";

// this is pseudocode to show how to properly handle errors
export const GET = async (req: Request) => {
	const url = new URL(req.url)
	const accessToken = req.headers.get('Authorization')
	try {
		const tokens = await checkMcp({
			auth,
			accessToken,
			baseUrl: `${url.protocol}//${url.hostname}${url.port ? ':' + url.port : ''}`,
			path: url.pathname,
		})
		// ...continue
	} catch (error) {
        handleMcpErrors(error)
	}
}
```

## Configuration

The you can opt-out of OIDC for a resource by simply removing the "openid" scope from the scopes_supported section.

The MCP plugin accepts the following configuration options:

<TypeTable
  type={{
    resourceServer: {
        description: "default settings for a new resource server",
        required: false,
    }
  }}
/>

### Resource Server Metadata

A resource server as defined by [RFC 9728](https://datatracker.ietf.org/doc/html/rfc9728) specifies details pertaining to a specific endpoint on your server (aka resource server).

### OIDC Configuration

The plugin supports additional OIDC configuration options through the `oidcConfig` parameter:

<TypeTable
  type={{
    resource: {
        description: "URL of the your endpoint",
        type: "string",
        required: true,
    },
    authorization_servers: {
        description: "Authorization Servers. Requires at least one.",
        type: "string[]",
        required: false,
        default: "[`${baseUrl}/.well-known/oauth-authorization-server`]"
    },
    jwks_uri: {
        description: "URL of the protected resource's JSON Web Key (JWK) Set",
        type: "string",
        required: false,
    },
    scopes_supported: {
        description: "List of scope values",
        type: "string[]",
        required: false,
    },
    bearer_methods_supported: {
        description: "List of the supported methods of sending an OAuth 2.0 bearer token",
        type: "string[]",
        required: false,
    },
    resource_signing_alg_values_supported: {
        description: "List of the JWS signing algorithms used",
        type: "string[]",
        required: false,
    },
    resource_name: {
        description: "Human-readable name intended for display to the end user",
        type: "string",
        required: false,
    },
    resource_documentation: {
        description: "URL that developers might want when using the protected resource",
        type: "string",
        required: false,
    },
    resource_policy_uri: {
        description: "URL of the resource's usage policy requirements",
        type: "string",
        required: false,
    },
    resource_tos_uri: {
        description: "URL of the resource's resource's terms of service",
        type: "string",
        required: false,
    },
    tls_client_certificate_bound_access_tokens: {
        description: "Indicates protected resource support for mutual-TLS client certificate-bound access tokens",
        type: "boolean",
        required: false,
    },
    authorization_details_types_supported: {
        description: "List of the authorization details type values supported by the resource server when the authorization_details request parameter",
        type: "string",
        required: false,
    },
    dpop_signing_alg_values_supported: {
        description: "List of the JWS alg values supported by the resource server for validating Demonstrating Proof of Possession (DPoP) proof JWTs",
        type: "string",
        required: false,
    },
    dpop_bound_access_tokens_required: {
        description: "Specifies whether the protected resource always requires the use of DPoP-bound access tokens",
        type: "boolean",
        required: false,
    }
  }}
/>
