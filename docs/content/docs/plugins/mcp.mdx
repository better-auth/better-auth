---
title: MCP (Model Context Protocol)
description: OAuth provider plugin for MCP clients
---

`OAuth` `MCP`

The **MCP** plugin enables your Better Auth application to act as an OAuth 2.0 authorization server for [Model Context Protocol](https://modelcontextprotocol.io) clients. It provides OAuth 2.0 authorization code flow with PKCE support, dynamic client registration, and token management.

<Callout type="info">
You only need to configure the plugin and use `withMcpAuth` to protect your MCP endpoints. The OAuth flow is automatically handled by Better Auth. Jump to [Protecting Your MCP Endpoints](#protecting-your-mcp-endpoints) for implementation details.
</Callout>

<Callout type="warn">
This plugin is based on OIDC Provider plugin. It's currently not ready for production use. We are working on it and will update this documentation when it's ready.
</Callout>

## Installation

<Steps>
    <Step>
        ### Add the Plugin

        Add the MCP plugin to your auth configuration and specify the login page path.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth";
        import { mcp } from "better-auth/plugins";

        export const auth = betterAuth({
            plugins: [
                mcp({
                    loginPage: "/sign-in" // path to your login page
                })
            ]
        });
        ```
        <Callout>
            This plugin does not have a client plugin, so you don't need to make any changes to your authClient.
        </Callout>
    </Step>

    <Step>
        ### Migrate the Database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```package-install
            npx @better-auth/cli migrate
            ```
            </Tab>
            <Tab value="generate">
            ```package-install
            npx @better-auth/cli generate
            ```
            </Tab>
        </Tabs>
        The MCP plugin uses the same schema as the OIDC Provider plugin. See the [OIDC Provider Schema](/docs/plugins/oidc-provider#schema) section for details.
    </Step>
</Steps>

## Usage

### Protecting Your MCP Endpoints

The most important part for application developers is using `withMcpAuth` to protect your MCP endpoints. This helper function automatically validates OAuth access tokens from MCP clients.

#### Using `withMcpAuth` Helper

The `withMcpAuth` helper automatically validates the access token and handles authentication errors:

```ts title="api/[transport]/route.ts"
import { auth } from "@/lib/auth";
import { createMcpHandler } from "@vercel/mcp-adapter";
import { withMcpAuth } from "better-auth/plugins";
import { z } from "zod";

const handler = withMcpAuth(auth, (req, session) => {
    return createMcpHandler(
        (server) => {
            server.tool(
                "echo",
                "Echo a message",
                { message: z.string() },
                async ({ message }) => {
                    return {
                        content: [{ type: "text", text: `Tool echo: ${message}` }],
                    };
                },
            );
        },
        {
            capabilities: {
                tools: {
                    echo: {
                        description: "Echo a message",
                    },
                },
            },
        },
        {
            redisUrl: process.env.REDIS_URL,
            basePath: "/api",
            verboseLogs: true,
            maxDuration: 60,
        },
    )(req);
});

export { handler as GET, handler as POST, handler as DELETE };
```

The `withMcpAuth` helper automatically:
- Extracts the access token from the `Authorization` header
- Validates the token and checks expiration
- Returns a properly formatted 401 error with `WWW-Authenticate` header if authentication fails
- Exposes the `WWW-Authenticate` header via CORS for browser-based clients

#### Using `auth.api.getMcpSession`

For more control, you can manually handle session validation:

```ts title="api/[transport]/route.ts"
import { auth } from "@/lib/auth";
import { createMcpHandler } from "@vercel/mcp-adapter";
import { z } from "zod";

const handler = async (req: Request) => {
    // Get session using the access token from request headers
    const session = await auth.api.getMcpSession({
        headers: req.headers
    });
    
    if (!session) {
        // Important: Return 401 with WWW-Authenticate header
        return new Response(
            JSON.stringify({
                jsonrpc: "2.0",
                error: {
                    code: -32000,
                    message: "Unauthorized: Authentication required",
                },
                id: null,
            }),
            {
                status: 401,
                headers: {
                    "WWW-Authenticate": 'Bearer resource_metadata="https://your-domain.com/.well-known/oauth-protected-resource"',
                    "Content-Type": "application/json",
                },
            }
        );
    }
    
    return createMcpHandler(
        (server) => {
            server.tool(
                "echo",
                "Echo a message",
                { message: z.string() },
                async ({ message }) => {
                    return {
                        content: [{ type: "text", text: `Tool echo: ${message}` }],
                    };
                },
            );
        },
        {
            capabilities: {
                tools: {
                    echo: {
                        description: "Echo a message",
                    },
                },
            },
        },
        {
            redisUrl: process.env.REDIS_URL,
            basePath: "/api",
            verboseLogs: true,
            maxDuration: 60,
        },
    )(req);
}

export { handler as GET, handler as POST, handler as DELETE };
```

#### Scope-Based Authorization

You can check scopes to implement fine-grained access control:

```ts title="api/protected-resource/route.ts"
import { auth } from "@/lib/auth";
import { withMcpAuth } from "better-auth/plugins";

const handler = withMcpAuth(auth, (req, session) => {
    const scopes = session.scopes.split(" ");
    
    // Check if the client has the required scope
    if (!scopes.includes("read:data")) {
        return new Response(
            JSON.stringify({ error: "insufficient_scope" }),
            { 
                status: 403,
                headers: {
                    "WWW-Authenticate": 'Bearer error="insufficient_scope", scope="read:data"'
                }
            }
        );
    }
    
    // Proceed with the request
    return Response.json({ data: "Protected data" });
});

export { handler as GET };
```

## OAuth Flow Reference

<Callout type="info">
This section contains technical details about the OAuth 2.0 flow. Application developers using Better Auth don't need to implement these - they are automatically handled by the plugin.
</Callout>

This section documents the OAuth 2.0 endpoints provided by the MCP plugin for reference and debugging purposes.

### Client Registration

MCP clients can register with your authorization server using the dynamic client registration endpoint.

<Endpoint path="/mcp/register" method="POST" />

For detailed client registration documentation and examples, see the [OIDC Provider documentation](/docs/plugins/oidc-provider#register-a-new-client).

### Discovery Endpoints

#### OAuth Authorization Server Metadata

Better Auth automatically provides the OAuth Authorization Server Metadata at `/api/auth/.well-known/oauth-authorization-server`. For better compatibility with some clients, you can also expose it at the root level:

```ts title=".well-known/oauth-authorization-server/route.ts"
import { oAuthDiscoveryMetadata } from "better-auth/plugins";
import { auth } from "@/lib/auth";

export const GET = oAuthDiscoveryMetadata(auth);
```

#### OAuth Protected Resource Metadata

Similarly, Better Auth provides Protected Resource Metadata at `/api/auth/.well-known/oauth-protected-resource`. You can expose it at root level:

```ts title="/.well-known/oauth-protected-resource/route.ts"
import { oAuthProtectedResourceMetadata } from "better-auth/plugins";
import { auth } from "@/lib/auth";

export const GET = oAuthProtectedResourceMetadata(auth);
```

### Authorization Flow

The plugin implements the OAuth 2.0 Authorization Code Flow with PKCE support:

1. **Authorization Request**: MCP client directs user to `/mcp/authorize`
2. **User Login**: User is redirected to your `loginPage` if not authenticated
3. **Authorization Code**: After login, user is redirected back to client with code
4. **Token Exchange**: Client exchanges code for tokens at `/mcp/token`

<Endpoint path="/mcp/authorize" method="GET" />
<Endpoint path="/mcp/token" method="POST" />

For detailed OAuth flow documentation, see the [OIDC Provider documentation](/docs/plugins/oidc-provider).

## Configuration

The MCP plugin accepts the following configuration options:

<TypeTable
  type={{
    loginPage: {
        description: "Path to the login page where users will be redirected for authentication",
        type: "string",
        required: true
    },
    resource: {
        description: "The resource identifier that should be returned by the protected resource metadata endpoint. Defaults to your server's origin (e.g., https://example.com)",
        type: "string",
        required: false
    },
    oidcConfig: {
        description: "Optional OIDC configuration options for advanced customization",
        type: "object",
        required: false
    }
  }}
/>

### Advanced Configuration

The plugin supports additional OIDC configuration options through the `oidcConfig` parameter:

<TypeTable
  type={{
    codeExpiresIn: {
        description: "Expiration time for authorization codes in seconds. Shorter times are more secure but may cause issues with slow networks.",
        type: "number",
        default: "600 (10 minutes)"
    },
    accessTokenExpiresIn: {
        description: "Expiration time for access tokens in seconds. Balance security with user experience.",
        type: "number",
        default: "3600 (1 hour)"
    },
    refreshTokenExpiresIn: {
        description: "Expiration time for refresh tokens in seconds. Longer times reduce re-authentication frequency.",
        type: "number",
        default: "604800 (7 days)"
    },
    defaultScope: {
        description: "Default scope used when clients don't specify scopes",
        type: "string",
        default: "openid"
    },
    scopes: {
        description: "Array of supported scopes. Add custom scopes here for your application.",
        type: "string[]",
        default: '["openid", "profile", "email", "offline_access"]'
    },
    requirePKCE: {
        description: "Whether to require PKCE (Proof Key for Code Exchange) for all authorization requests. Recommended for enhanced security.",
        type: "boolean",
        default: "false"
    },
    allowPlainCodeChallengeMethod: {
        description: "Allow plain PKCE code challenge method. Set to false for better security.",
        type: "boolean",
        default: "true"
    },
    metadata: {
        description: "Override OAuth authorization server metadata fields",
        type: "Partial<OIDCMetadata>",
        required: false
    }
  }}
/>

**Example with Custom Configuration**:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { mcp } from "better-auth/plugins";

export const auth = betterAuth({
  plugins: [
    mcp({
      loginPage: "/sign-in",
      resource: "https://api.example.com",
      oidcConfig: {
        // Shorter token lifetimes for enhanced security
        codeExpiresIn: 300, // 5 minutes
        accessTokenExpiresIn: 1800, // 30 minutes
        refreshTokenExpiresIn: 2592000, // 30 days
        
        // Custom scopes for your application
        scopes: [
          "openid",
          "profile",
          "email",
          "offline_access",
          "read:data",
          "write:data",
          "admin:access",
        ],
        
        // Security settings
        requirePKCE: true,
        allowPlainCodeChallengeMethod: false,
        
        // Custom metadata
        metadata: {
          issuer: "https://auth.example.com",
        },
      },
    }),
  ],
});
```

## Public vs Confidential Clients

The MCP plugin supports both public and confidential OAuth clients:

### Confidential Clients

Confidential clients can securely store client secrets (e.g., server-side applications, backend services).

```ts title="register-confidential-client.ts"
const response = await fetch("https://your-domain.com/api/auth/mcp/register", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    redirect_uris: ["https://server.example.com/callback"],
    client_name: "Server Application",
    token_endpoint_auth_method: "client_secret_basic", // or "client_secret_post"
    grant_types: ["authorization_code", "refresh_token"],
  }),
});

const { client_id, client_secret } = await response.json();
// Store client_secret securely on your server
```

### Public Clients

Public clients cannot securely store secrets (e.g., SPAs, mobile apps, CLI tools, desktop applications). They use PKCE for security.

```ts title="register-public-client.ts"
const response = await fetch("https://your-domain.com/api/auth/mcp/register", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    redirect_uris: ["com.example.app://callback"],
    client_name: "Mobile App",
    token_endpoint_auth_method: "none", // Indicates public client
    grant_types: ["authorization_code", "refresh_token"],
  }),
});

const { client_id } = await response.json();
// No client_secret for public clients
// MUST use PKCE for all authorization requests
```

<Callout type="info">
Public clients must use PKCE (Proof Key for Code Exchange) with the S256 code challenge method for secure authorization. The plugin validates PKCE for public clients automatically.
</Callout>

## Security Best Practices

### 1. Use PKCE for All Clients

Even for confidential clients, PKCE adds an additional layer of security:

```ts title="auth.ts"
export const auth = betterAuth({
  plugins: [
    mcp({
      loginPage: "/sign-in",
      oidcConfig: {
        requirePKCE: true, // Enforce PKCE for all clients
        allowPlainCodeChallengeMethod: false, // Only allow S256
      },
    }),
  ],
});
```

### 2. Refresh Token Management

The plugin issues new refresh tokens when access tokens are refreshed:

```ts title="refresh-token.ts"
const response = await fetch("https://your-domain.com/api/auth/mcp/token", {
  method: "POST",
  body: new URLSearchParams({
    grant_type: "refresh_token",
    refresh_token: oldRefreshToken,
    client_id: "YOUR_CLIENT_ID",
  }),
});

const { access_token, refresh_token } = await response.json();
// A new refresh_token is issued, but the old one remains valid until expiration
```

<Callout type="warn">
**Token Rotation**: The plugin does not automatically revoke old refresh tokens. For enhanced security, implement manual token revocation by deleting old tokens from the `oauthAccessToken` table after issuing new ones.
</Callout>

### 3. Validate Redirect URIs

Always register exact redirect URIs, never use wildcards:

```ts title="register-with-exact-uris.ts"
{
  redirect_uris: [
    "https://app.example.com/auth/callback",
    "https://app.example.com/auth/silent-callback",
  ]
  // âŒ Never use: ["https://app.example.com/*"]
}
```

### 4. Use Short-Lived Access Tokens

Configure shorter access token lifetimes and use refresh tokens:

```ts title="auth.ts"
export const auth = betterAuth({
  plugins: [
    mcp({
      loginPage: "/sign-in",
      oidcConfig: {
        accessTokenExpiresIn: 900, // 15 minutes
        refreshTokenExpiresIn: 604800, // 7 days
        scopes: ["openid", "profile", "email", "offline_access"],
      },
    }),
  ],
});
```

### 5. Scope-Based Access Control

Implement fine-grained permissions using scopes:

```ts title="auth.ts"
export const auth = betterAuth({
  plugins: [
    mcp({
      loginPage: "/sign-in",
      oidcConfig: {
        scopes: [
          "openid",
          "profile",
          "email",
          "offline_access",
          "read:users",
          "write:users",
          "read:admin",
          "write:admin",
        ],
      },
    }),
  ],
});
```

Then validate scopes in your endpoints:

```ts title="protected-endpoint.ts"
import { auth } from "@/lib/auth";
import { withMcpAuth } from "better-auth/plugins";

const handler = withMcpAuth(auth, (req, session) => {
  const requiredScopes = ["write:admin"];
  const clientScopes = session.scopes.split(" ");
  
  const hasPermission = requiredScopes.every(scope => 
    clientScopes.includes(scope)
  );
  
  if (!hasPermission) {
    return new Response(JSON.stringify({ error: "insufficient_scope" }), {
      status: 403,
      headers: {
        "WWW-Authenticate": `Bearer error="insufficient_scope", scope="${requiredScopes.join(" ")}"`,
      },
    });
  }
  
  // Process authorized request
  return Response.json({ success: true });
});
```

## Schema

The MCP plugin uses the same database schema as the OIDC Provider plugin. See the [OIDC Provider Schema](/docs/plugins/oidc-provider#schema) documentation for complete table definitions and field descriptions.
