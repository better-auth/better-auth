---
title: Single Sign-On (SSO)
description: Integrate Single Sign-On (SSO) with your application.
---

`OIDC` `OAuth2` `SSO` `SAML`

Single Sign-On (SSO) allows users to authenticate with multiple applications using a single set of credentials. This plugin supports OpenID Connect (OIDC), OAuth2 providers, and SAML 2.0.

## Installation

<Steps>
    <Step>
        ### Install the plugin

        ```package-install
        @better-auth/sso
        ```
    </Step>
    <Step>
        ### Add Plugin to the server

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { sso } from "@better-auth/sso"; // [!code highlight]

        const auth = betterAuth({
            plugins: [
                sso() // [!code highlight]
            ]
        })
        ```
    </Step>
    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```package-install
            npx @better-auth/cli migrate
            ```
            </Tab>
            <Tab value="generate">
            ```package-install
            npx @better-auth/cli generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>
    <Step>
        ### Add the client plugin

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { ssoClient } from "@better-auth/sso/client" // [!code highlight]

        const authClient = createAuthClient({
            plugins: [
                ssoClient() // [!code highlight]
            ]
        })
        ```
    </Step>
</Steps>

## Usage

### Register an OIDC Provider

To register an OIDC provider, use the `registerSSOProvider` endpoint and provide the necessary configuration details for the provider.

A redirect URL will be automatically generated using the provider ID. For instance, if the provider ID is `hydra`, the redirect URL would be `{baseURL}/api/auth/sso/callback/hydra`. Note that `/api/auth` may vary depending on your base path configuration.

<Callout type="info">
When you register an OIDC provider, Better Auth automatically fetches and validates the IdP's [OIDC discovery document](#oidc-discovery). Most endpoint fields are optional — see [OIDC Discovery](#oidc-discovery) for details on auto-discovered fields and possible registration errors.
</Callout>

#### Example

<Tabs items={["client", "server"]}>
    <Tab value="client">
```ts title="register-oidc-provider.ts"
import { authClient } from "@/lib/auth-client";

// Register with OIDC configuration
await authClient.sso.register({
    providerId: "example-provider",
    issuer: "https://idp.example.com",
    domain: "example.com",
    oidcConfig: {
        clientId: "client-id",
        clientSecret: "client-secret",
        authorizationEndpoint: "https://idp.example.com/authorize",
        tokenEndpoint: "https://idp.example.com/token",
        jwksEndpoint: "https://idp.example.com/jwks",
        discoveryEndpoint: "https://idp.example.com/.well-known/openid-configuration",
        scopes: ["openid", "email", "profile"],
        pkce: true,
        mapping: {
            id: "sub",
            email: "email",
            emailVerified: "email_verified",
            name: "name",
            image: "picture",
            extraFields: {
                department: "department",
                role: "role"
            }
        }
    }
});
```
    </Tab>

    <Tab value="server">
```ts title="register-oidc-provider.ts"
const { headers } = await signInWithTestUser();
await auth.api.registerSSOProvider({
    body: {
        providerId: "example-provider",
        issuer: "https://idp.example.com",
        domain: "example.com",
        oidcConfig: {
            clientId: "your-client-id",
            clientSecret: "your-client-secret",
            authorizationEndpoint: "https://idp.example.com/authorize",
            tokenEndpoint: "https://idp.example.com/token",
            jwksEndpoint: "https://idp.example.com/jwks",
            discoveryEndpoint: "https://idp.example.com/.well-known/openid-configuration",
            scopes: ["openid", "email", "profile"],
            pkce: true,
            mapping: {
                id: "sub",
                email: "email",
                emailVerified: "email_verified",
                name: "name",
                image: "picture",
                extraFields: {
                    department: "department",
                    role: "role"
                }
            }
        }
    },
    headers,
});
```
    </Tab>
</Tabs>

### OIDC Discovery

Better Auth automatically fetches and validates the provider's [OpenID Connect Discovery Document](https://openid.net/specs/openid-connect-discovery-1_0.html) from:

```
{issuer}/.well-known/openid-configuration
```

This allows most endpoint-related fields in `oidcConfig` to be **optional** — they will be hydrated automatically from the Identity Provider (IdP).

<APIMethod path="/sso/register" method="POST" requireSession note="Minimal OIDC configuration — endpoints are discovered automatically from the issuer.">
```ts
type registerSSOProvider = {
    /**
     * Unique identifier for the provider
     */
    providerId: string = "okta"
    /**
     * The OIDC issuer URL. Discovery document is fetched from `{issuer}/.well-known/openid-configuration`
     */
    issuer: string = "https://your-org.okta.com"
    /**
     * Email domain for this provider
     */
    domain: string = "yourcompany.com"
    /**
     * OIDC configuration (most fields are auto-discovered)
     */
    oidcConfig: {
        /**
         * OAuth client ID from your IdP
         */
        clientId: string = "your-client-id"
        /**
         * OAuth client secret from your IdP
         */
        clientSecret: string = "your-client-secret"
    }
}
```
</APIMethod>

#### Fields Automatically Discovered

Better Auth fills in the following fields by reading the IdP's discovery document (if not explicitly provided):

- `authorizationEndpoint`
- `tokenEndpoint`
- `jwksEndpoint`
- `userInfoEndpoint`
- `discoveryEndpoint`
- `tokenEndpointAuthentication` (method for token endpoint client authentication)

Following the spec, our discovery process expects all URLs to be valid and to be absolute urls. Relative paths are also supported and resolved relative to the issuer's base URL preserving the path when available.

Example of relative endpoint and issuer without base path:

- `issuer`: `"https://your-org.okta.com"`
- `token_endpoint`: `"/v1/tokens"`
- normalized `token_endpoint`: `"https://your-org.okta.com/v1/tokens"`


Example of relative endpoint and issuer with base path:

- `issuer`: `"https://your-org.okta.com/v1"`
- `token_endpoint`: `"/tokens"`
- normalized `token_endpoint`: `"https://your-org.okta.com/v1/tokens"`

<Callout type="info">
If you explicitly set these fields in `oidcConfig`, your values override the discovered ones.
This is useful when you need to override the IdP's advertised metadata or when using incomplete mock servers.
</Callout>

#### Trusted origins

Both the discovery endpoint as well as any URL resolved through the discovery process are subject to your app's [`trustedOrigins`](/docs/reference/security#trusted-origins) configuration.
Discovery will fail with the `discovery_untrusted_origin` code unless you explicitly update your `trustedOrigins` configuration:

```ts
trustedOrigins: ["https://your-org.okta.com"],
```

If your use-case requires to support multiple arbitrary but known IDPs (e.g Okta), we recommend to:

1. Register a list of well known IDPs ahead of time

```ts
trustedOrigins: [
    "https://your-org.okta.com",
    "https://accounts.google.com",
    "https://login.microsoftonline.com",
    "https://auth0.com",
    "https://idp.example.com"
],
```

2. Or dynamically compute the `trustedOrigins` by specifying a callback function:

```ts
trustedOrigins: async (request) => {
    // request is undefined during initialization and auth.api calls
    if (!request) {
        return ["https://my-frontend.com"];
    }

    // SSO trusted origin list
    if (request.url.endsWith("/sso/register")) {
        const trustedOrigins = await fetchOriginList();
        return trustedOrigins;
    }

    // Your normal origin list for everything else
    return [];
}
```

See the [`trustedOrigins`](/docs/reference/security#trusted-origins) docs for more information.

#### Why Discovery Can Fail

Better Auth validates that the IdP's metadata is correct and complete **before** allowing registration. This prevents subtle runtime failures during sign-in or token validation.

<Callout type="info">
Better Auth does **not** support implicit-only OIDC flows.
For this reason, `token_endpoint` and `jwks_uri` are required even though the OIDC spec allows implicit-only providers to omit `token_endpoint`.
</Callout>

#### Discovery Errors

If the Identity Provider is misconfigured or unreachable, registration will fail with a structured error.

| Error Code | Meaning |
|------------|---------|
| `issuer_mismatch` | The IdP's discovery document reports a different `issuer` than the one you configured |
| `discovery_incomplete` | Required fields (`authorization_endpoint`, `token_endpoint`, `jwks_uri`) are missing |
| `discovery_not_found` | The discovery document endpoint returned 404 |
| `discovery_timeout` | The IdP did not respond within the timeout window (default: 10 seconds) |
| `discovery_invalid_url` | The discovery URL is malformed or uses an unsupported protocol |
| `discovery_untrusted_origin` | The discovery URL or one of the URLs discovered as part of this process was not trusted by your app's trusted origins configuration |
| `discovery_invalid_json` | The discovery response is empty or not valid JSON |
| `unsupported_token_auth_method` | The IdP only supports token auth methods that Better Auth doesn't support |

**Supported token auth methods:**
- `client_secret_basic`
- `client_secret_post`

<Callout type="warning">
If your IdP advertises only unsupported methods (e.g., `private_key_jwt`, `tls_client_auth`, or `"none"` for public clients), you can explicitly override the method:

```ts
oidcConfig: {
    clientId: "your-client-id",
    clientSecret: "your-client-secret",
    tokenEndpointAuthentication: "client_secret_basic", // Override discovery
}
```

This is especially common with mock OIDC servers or development IdPs that only advertise `"none"` as the supported method.
</Callout>

#### Summary

- Better Auth automatically performs OIDC discovery at registration time
- Most endpoint settings in `oidcConfig` become optional
- Explicit user configuration always overrides discovery
- Registration fails fast if the IdP is misconfigured
- Discovery errors are structured and well-defined
- Public-client IdPs or mock servers may require overriding `tokenEndpointAuthentication`

### Register a SAML Provider

To register a SAML provider, use the `registerSSOProvider` endpoint with SAML configuration details. The provider will act as a Service Provider (SP) and integrate with your Identity Provider (IdP).

<Tabs items={["client", "server"]}>
    <Tab value="client">
```ts title="register-saml-provider.ts"
import { authClient } from "@/lib/auth-client";

await authClient.sso.register({
    providerId: "saml-provider",
    issuer: "https://idp.example.com",
    domain: "example.com",
    samlConfig: {
        entryPoint: "https://idp.example.com/sso",
        cert: "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----",
        callbackUrl: "https://yourapp.com/api/auth/sso/saml2/callback/saml-provider",
        audience: "https://yourapp.com",
        wantAssertionsSigned: true,
        signatureAlgorithm: "sha256",
        digestAlgorithm: "sha256",
        identifierFormat: "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress",
        idpMetadata: {
            metadata: "<!-- IdP Metadata XML -->",
            privateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----",
            privateKeyPass: "your-private-key-password",
            isAssertionEncrypted: true,
            encPrivateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----",
            encPrivateKeyPass: "your-encryption-key-password"
        },
        spMetadata: {
            metadata: "<!-- SP Metadata XML -->",
            binding: "post",
            privateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----",
            privateKeyPass: "your-sp-private-key-password",
            isAssertionEncrypted: true,
            encPrivateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----",
            encPrivateKeyPass: "your-sp-encryption-key-password"
        },
        mapping: {
            id: "nameID",
            email: "email",
            name: "displayName",
            firstName: "givenName",
            lastName: "surname",
            emailVerified: "email_verified",
            extraFields: {
                department: "department",
                role: "role"
            }
        }
    }
});
```
    </Tab>

    <Tab value="server">
```ts title="register-saml-provider.ts"
const { headers } = await signInWithTestUser();
await auth.api.registerSSOProvider({
    body: {
        providerId: "saml-provider",
        issuer: "https://idp.example.com",
        domain: "example.com",
        samlConfig: {
            entryPoint: "https://idp.example.com/sso",
            cert: "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----",
            callbackUrl: "https://yourapp.com/api/auth/sso/saml2/callback/saml-provider",
            audience: "https://yourapp.com",
            wantAssertionsSigned: true,
            signatureAlgorithm: "sha256",
            digestAlgorithm: "sha256",
            identifierFormat: "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress",
            idpMetadata: {
                metadata: "<!-- IdP Metadata XML -->",
                privateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----",
                privateKeyPass: "your-private-key-password",
                isAssertionEncrypted: true,
                encPrivateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----",
                encPrivateKeyPass: "your-encryption-key-password"
            },
            spMetadata: {
                metadata: "<!-- SP Metadata XML -->",
                binding: "post",
                privateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----",
                privateKeyPass: "your-sp-private-key-password",
                isAssertionEncrypted: true,
                encPrivateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----",
                encPrivateKeyPass: "your-sp-encryption-key-password"
            },
            mapping: {
                id: "nameID",
                email: "email",
                name: "displayName",
                firstName: "givenName",
                lastName: "surname",
                emailVerified: "email_verified",
                extraFields: {
                    department: "department",
                    role: "role"
                }
            }
        }
    },
    headers,
});
```
    </Tab>
</Tabs>

### IdP-Initiated SSO

 For IdP-initiated flows (e.g., via Okta dashboard), your framework may require an explicit route handler to manage the redirect if the default handler doesn't support the `GET` request following the SAML POST.

 <Tabs items={["next-js-app-router"]}>
   <Tab value="next-js-app-router">
     Create this file to prevent 404 errors:

     ```ts title="app/api/auth/sso/saml2/callback/[providerId]/route.ts"
     import { auth } from "@/lib/auth";
     import { NextResponse } from "next/server";

     export async function POST(req: Request) {
         return auth.handler(req);
     }

     export async function GET(req: Request) {
         // Required: IdP-initiated flows redirect to this URL after POST
         return NextResponse.redirect(new URL("/", req.url));
     }
     ```
   </Tab>
</Tabs>

### Get Service Provider Metadata

For SAML providers, you can retrieve the Service Provider metadata XML that needs to be configured in your Identity Provider:

```ts title="get-sp-metadata.ts"
const response = await auth.api.spMetadata({
    query: {
        providerId: "saml-provider",
        format: "xml" // or "json"
    }
});

const metadataXML = await response.text();
console.log(metadataXML);
```

### Sign In with SSO

To sign in with an SSO provider, you can call `signIn.sso`

You can sign in using the email with domain matching:

```ts title="sign-in.ts"
import { authClient } from "@/lib/auth-client"

const res = await authClient.signIn.sso({
    email: "user@example.com",
    callbackURL: "/dashboard",
});
```

or you can specify the domain:

```ts title="sign-in-domain.ts"
import { authClient } from "@/lib/auth-client"

const res = await authClient.signIn.sso({
    domain: "example.com",
    callbackURL: "/dashboard",
});
```

You can also sign in using the organization slug if a provider is associated with an organization:

```ts title="sign-in-org.ts"
import { authClient } from "@/lib/auth-client"

const res = await authClient.signIn.sso({
    organizationSlug: "example-org",
    callbackURL: "/dashboard",
});
```

Alternatively, you can sign in using the provider's ID:

```ts title="sign-in-provider-id.ts"
import { authClient } from "@/lib/auth-client"

const res = await authClient.signIn.sso({
    providerId: "example-provider-id",
    callbackURL: "/dashboard",
});
```

Optionally, you can pass a login hint (for example, an email address or another identifier) to prefill or direct the identity provider:

```ts title="sign-in-with-login-hint.ts"
import { authClient } from "@/lib/auth-client"

const res = await authClient.signIn.sso({
    providerId: "example-provider-id",
    loginHint: "user@example.com",
    callbackURL: "/dashboard",
});
```

To use the server API you can use `signInSSO`

```ts title="sign-in-org.ts"
import { authClient } from "@/lib/auth-client"

const res = await auth.api.signInSSO({
    body: {
        organizationSlug: "example-org",
        callbackURL: "/dashboard",
    }
});
```

#### Full method

<APIMethod path="/sign-in/sso" method="POST">
```ts
type signInSSO = {
    /**
     * The email address to sign in with. This is used to identify the issuer to sign in with. It's optional if the issuer is provided. 
     */
    email?: string = "john@example.com"
    /**
     * The slug of the organization to sign in with. 
     */
    organizationSlug?: string = "example-org"
    /**
     * The ID of the provider to sign in with. This can be provided instead of email or issuer. 
     */
    providerId?: string = "example-provider"
    /**
     * The domain of the provider. 
     */
    domain?: string = "example.com"
    /**
     * The URL to redirect to after login. 
     */
    callbackURL: string = "https://example.com/callback"
    /**
     * The URL to redirect to after login. 
     */
    errorCallbackURL?: string = "https://example.com/callback"
    /**
     * The URL to redirect to after login if the user is new. 
     */
    newUserCallbackURL?: string = "https://example.com/new-user"
    /**
     * Scopes to request from the provider. 
     */
    scopes?: string[] = ["openid", "email", "profile", "offline_access"]
    /**
     * Login hint to send to the identity provider (e.g., email or identifier). 
     */
    loginHint?: string = "user@example.com"
    /**
     * Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider. 
     */
    requestSignUp?: boolean = true
}
```
</APIMethod>

Note: If email is provided and loginHint is not specified, email will be sent as the login_hint to OIDC providers automatically. SAML flows do not support login_hint.

When a user is authenticated, if the user does not exist, the user will be provisioned using the `provisionUser` function. If the organization provisioning is enabled and a provider is associated with an organization, the user will be added to the organization.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({
            provisionUser: async (user) => {
                // provision user
            },
            organizationProvisioning: {
                disabled: false,
                defaultRole: "member",
                getRole: async (user) => {
                    // get role if needed
                },
            },
        }),
    ],
});
```

## Provisioning

The SSO plugin provides powerful provisioning capabilities to automatically set up users and manage their organization memberships when they sign in through SSO providers.

### User Provisioning

User provisioning allows you to run custom logic whenever a user signs in through an SSO provider. This is useful for:

- Setting up user profiles with additional data from the SSO provider
- Synchronizing user attributes with external systems
- Creating user-specific resources
- Logging SSO sign-ins
- Updating user information from the SSO provider

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({
            provisionUser: async ({ user, userInfo, token, provider }) => {
                // Update user profile with SSO data
                await updateUserProfile(user.id, {
                    department: userInfo.attributes?.department,
                    jobTitle: userInfo.attributes?.jobTitle,
                    manager: userInfo.attributes?.manager,
                    lastSSOLogin: new Date(),
                });

                // Create user-specific resources
                await createUserWorkspace(user.id);

                // Sync with external systems
                await syncUserWithCRM(user.id, userInfo);

                // Log the SSO sign-in
                await auditLog.create({
                    userId: user.id,
                    action: 'sso_signin',
                    provider: provider.providerId,
                    metadata: {
                        email: userInfo.email,
                        ssoProvider: provider.issuer,
                    },
                });
            },
        }),
    ],
});
```

The `provisionUser` function receives:
- **user**: The user object from the database
- **userInfo**: User information from the SSO provider (includes attributes, email, name, etc.)
- **token**: OAuth2 tokens (for OIDC providers) - may be undefined for SAML
- **provider**: The SSO provider configuration

### Organization Provisioning

Organization provisioning automatically manages user memberships in organizations when SSO providers are linked to specific organizations. This is particularly useful for:

- Enterprise SSO where each company/domain maps to an organization
- Automatic role assignment based on SSO attributes
- Managing team memberships through SSO

#### Basic Organization Provisioning

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({
            organizationProvisioning: {
                disabled: false,           // Enable org provisioning
                defaultRole: "member",     // Default role for new members
            },
        }),
    ],
});
```

#### Advanced Organization Provisioning with Custom Roles

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({
            organizationProvisioning: {
                disabled: false,
                defaultRole: "member",
                getRole: async ({ user, userInfo, provider }) => {
                    // Assign roles based on SSO attributes
                    const department = userInfo.attributes?.department;
                    const jobTitle = userInfo.attributes?.jobTitle;
                    
                    // Admins based on job title
                    if (jobTitle?.toLowerCase().includes('manager') || 
                        jobTitle?.toLowerCase().includes('director') ||
                        jobTitle?.toLowerCase().includes('vp')) {
                        return "admin";
                    }
                    
                    // Special roles for IT department
                    if (department?.toLowerCase() === 'it') {
                        return "admin";
                    }
                    
                    // Default to member for everyone else
                    return "member";
                },
            },
        }),
    ],
});
```

#### Linking SSO Providers to Organizations

When registering an SSO provider, you can link it to a specific organization:

```ts title="register-org-provider.ts"
import { auth } from "@/lib/auth"

await auth.api.registerSSOProvider({
    body: {
        providerId: "acme-corp-saml",
        issuer: "https://acme-corp.okta.com",
        domain: "acmecorp.com",
        organizationId: "org_acme_corp_id", // Link to organization
        samlConfig: {
            // SAML configuration...
        },
    },
    headers: await headers() // headers containing the user's session token
});
```

Now when users from `acmecorp.com` sign in through this provider, they'll automatically be added to the "Acme Corp" organization with the appropriate role.

#### Multiple Organizations Example

You can set up multiple SSO providers for different organizations:

```ts title="multi-org-setup.ts"
import { auth } from "@/lib/auth"

// Acme Corp SAML provider
await auth.api.registerSSOProvider({
    body: {
        providerId: "acme-corp",
        issuer: "https://acme.okta.com",
        domain: "acmecorp.com",
        organizationId: "org_acme_id",
        samlConfig: { /* ... */ },
    },
    headers,
});

// TechStart OIDC provider
await auth.api.registerSSOProvider({
    body: {
        providerId: "techstart-google",
        issuer: "https://accounts.google.com",
        domain: "techstart.io",
        organizationId: "org_techstart_id",
        oidcConfig: { /* ... */ },
    },
    headers,
});
```

#### Organization Provisioning Flow

1. **User signs in** through an SSO provider linked to an organization
2. **User is authenticated** and either found or created in the database
3. **Organization membership is checked** - if the user isn't already a member of the linked organization
4. **Role is determined** using either the `defaultRole` or `getRole` function
5. **User is added** to the organization with the determined role
6. **User provisioning runs** (if configured) for additional setup

### Provisioning Best Practices

#### 1. Idempotent Operations
Make sure your provisioning functions can be safely run multiple times:

```ts
provisionUser: async ({ user, userInfo }) => {
    // Check if already provisioned
    const existingProfile = await getUserProfile(user.id);
    if (!existingProfile.ssoProvisioned) {
        await createUserResources(user.id);
        await markAsProvisioned(user.id);
    }
    
    // Always update attributes (they might change)
    await updateUserAttributes(user.id, userInfo.attributes);
},
```

#### 2. Error Handling
Handle errors gracefully to avoid blocking user sign-in:

```ts
provisionUser: async ({ user, userInfo }) => {
    try {
        await syncWithExternalSystem(user, userInfo);
    } catch (error) {
        // Log error but don't throw - user can still sign in
        console.error('Failed to sync user with external system:', error);
        await logProvisioningError(user.id, error);
    }
},
```

#### 3. Conditional Provisioning
Only run certain provisioning steps when needed:

```ts
organizationProvisioning: {
    disabled: false,
    getRole: async ({ user, userInfo, provider }) => {
        // Only process role assignment for certain providers
        if (provider.providerId.includes('enterprise')) {
            return determineEnterpriseRole(userInfo);
        }
        return "member";
    },
},
```

## SAML Configuration


### Default SSO Provider

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({
            defaultSSO: [
                {
                    providerId: "default-saml", // Provider ID for the default provider
                    domain: "http://your-app.com",
                    samlConfig: {
                        issuer: "https://your-app.com",
                        entryPoint: "https://idp.example.com/sso",
                        cert: "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----",
                        callbackUrl: "http://localhost:3000/api/auth/sso/saml2/sp/acs",
                        spMetadata: {
                            entityID: "http://localhost:3000/api/auth/sso/saml2/sp/metadata",
                            metadata: "<!-- Your SP Metadata XML -->",
                        }
                    }
                }
            ]
        })
    ]
});
```

The defaultSSO provider will be used when:
1. No matching provider is found in the database

This allows you to test SAML authentication without setting up providers in the database. The defaultSSO provider supports all the same configuration options as regular SAML providers.

### Service Provider Configuration

When registering a SAML provider, you need to provide Service Provider (SP) metadata configuration:

- **metadata**: XML metadata for the Service Provider
- **binding**: The binding method, typically "post" or "redirect"
- **privateKey**: Private key for signing AuthnRequests
- **privateKeyPass**: Password for the private key
- **isAssertionEncrypted**: Whether assertions should be encrypted
- **encPrivateKey**: Private key for decryption (if encryption is enabled)
- **encPrivateKeyPass**: Password for the encryption private key

### Signed AuthnRequests

Some enterprise IdPs (Okta, Azure AD, ADFS) require signed AuthnRequests. Enable this with:

```ts
samlConfig: {
    // ... other config
    authnRequestsSigned: true,
    spMetadata: {
        privateKey: "-----BEGIN RSA PRIVATE KEY-----\n...",
    }
}
```

The SP metadata endpoint will automatically include `AuthnRequestsSigned="true"` when enabled.

### Identity Provider Configuration

You also need to provide Identity Provider (IdP) configuration:

- **metadata**: XML metadata from your Identity Provider
- **privateKey**: Private key for the IdP communication (optional)
- **privateKeyPass**: Password for the IdP private key (if encrypted)
- **isAssertionEncrypted**: Whether assertions from IdP are encrypted
- **encPrivateKey**: Private key for IdP assertion decryption
- **encPrivateKeyPass**: Password for the IdP decryption key

### SAML Attribute Mapping

Configure how SAML attributes map to user fields:

```ts
mapping: {
    id: "nameID",           // Default: "nameID"
    email: "email",         // Default: "email" or "nameID"
    name: "displayName",    // Default: "displayName"
    firstName: "givenName", // Default: "givenName"
    lastName: "surname",    // Default: "surname"
    extraFields: {
        department: "department",
        role: "jobTitle",
        phone: "telephoneNumber"
    }
}
```

## SAML Security

The SSO plugin includes optional security features to protect against common SAML vulnerabilities.

### AuthnRequest / InResponseTo Validation

You can enable InResponseTo validation for SP-initiated SAML flows. When enabled, the plugin tracks AuthnRequest IDs and validates the `InResponseTo` attribute in SAML responses. This prevents:

- **Unsolicited responses**: Responses not triggered by a legitimate login request
- **Replay attacks**: Reusing old SAML responses
- **Cross-provider injection**: Responses meant for a different provider

<Callout type="info">
This feature is **opt-in** to ensure backward compatibility. Enable it explicitly for enhanced security.
</Callout>

#### Enabling Validation (Single Instance)

For single-instance deployments, enable validation with the built-in in-memory store:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({
            saml: {
                // Enable InResponseTo validation
                enableInResponseToValidation: true,
                // Optionally reject IdP-initiated SSO (stricter security)
                allowIdpInitiated: false,
                // Custom TTL for AuthnRequest validity (default: 5 minutes)
                requestTTL: 10 * 60 * 1000, // 10 minutes
            },
        }),
    ],
});
```

#### Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `enableInResponseToValidation` | `boolean` | `false` | Enable InResponseTo validation for SP-initiated flows. |
| `allowIdpInitiated` | `boolean` | `true` | Allow IdP-initiated SSO (responses without InResponseTo). Set to `false` for stricter security. Only applies when validation is enabled. |
| `requestTTL` | `number` | `300000` (5 min) | Time-to-live for AuthnRequest records in milliseconds. Requests older than this will be rejected. |

#### Error Handling

When InResponseTo validation fails, users are redirected with an error query parameter:

- `?error=invalid_saml_response&error_description=Unknown+or+expired+request+ID` — The request ID was not found or has expired
- `?error=invalid_saml_response&error_description=Provider+mismatch` — The response was meant for a different provider
- `?error=unsolicited_response&error_description=IdP-initiated+SSO+not+allowed` — IdP-initiated SSO is disabled

### Assertion Replay Protection

The SSO plugin includes assertion replay protection to prevent attackers from capturing and resubmitting valid SAML responses. Each SAML Assertion ID is tracked and rejected if reused.

<Callout type="info">
Replay protection is **always enabled**. This is a critical security feature that prevents attackers from reusing intercepted SAML responses.
</Callout>

#### How It Works

1. When a SAML response is received, the Assertion ID is extracted from the XML
2. The system checks if this Assertion ID has been seen before
3. If it's a new assertion, it's stored in the database until its `NotOnOrAfter` expiration
4. If it's a duplicate (replay attack), the request is rejected

**Both SAML endpoints are protected:**
- `/sso/saml2/callback/:providerId`
- `/sso/saml2/sp/acs/:providerId`

<Callout type="info">
Replay protection uses the database verification table, so it works correctly in multi-instance deployments without additional configuration.
</Callout>

#### Error Handling

When a replay attack is detected, users are redirected with an error:

- `?error=replay_detected&error_description=SAML+assertion+has+already+been+used` — The assertion ID was already used

### Timestamp Validation

The SSO plugin validates SAML assertion timestamps (`NotBefore` and `NotOnOrAfter`) to prevent acceptance of expired or future-dated assertions. This validation includes a configurable clock skew tolerance to account for time differences between servers.

#### SAML Specification Background

According to the **SAML 2.0 Core specification**, `NotBefore` and `NotOnOrAfter` attributes are **optional**. However, the widely-adopted **SAML2Int** (SAML V2.0 Implementation Profile for Federation Interoperability) specification **requires** these timestamps:

> "The Identity Provider MUST include a `<saml:Conditions>` element. Conditions restricting the period when the assertion is valid, the `@NotBefore` and `@NotOnOrAfter` MUST be included."

Better Auth provides flexibility to support both:
- **Default behavior**: Accepts assertions without timestamps (SAML 2.0 Core compliant) but logs a warning
- **Strict mode**: Rejects assertions without timestamps (SAML2Int compliant)

#### How It Works

For each SAML assertion:
- **NotBefore**: The assertion is rejected if current time is before `NotBefore - clockSkew`
- **NotOnOrAfter**: The assertion is rejected if current time is after `NotOnOrAfter + clockSkew`

#### Configuration

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({
            saml: {
                // Clock skew tolerance (default: 5 minutes)
                clockSkew: 5 * 60 * 1000,
                // Require timestamps in assertions (default: false)
                requireTimestamps: false,
            },
        }),
    ],
});
```

#### Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `clockSkew` | `number` | `300000` (5 min) | Clock skew tolerance in milliseconds. Allows for time differences between IdP and SP servers. |
| `requireTimestamps` | `boolean` | `false` | When `true`, assertions without `NotBefore`/`NotOnOrAfter` conditions are rejected. When `false`, they are accepted but a warning is logged. |

#### When to Enable `requireTimestamps`

<Callout type="info">
**Recommendation**: Enable `requireTimestamps: true` for enterprise and high-security deployments.
</Callout>

Enable `requireTimestamps: true` when:
- Your IdP follows **SAML2Int** (most enterprise IdPs like Okta, Azure AD, OneLogin)
- You need **SOC 2**, **ISO 27001**, or similar compliance
- You want to prevent acceptance of malformed or test assertions
- You're in a **production environment** with proper IdP configuration

Keep `requireTimestamps: false` (default) when:
- Integrating with **legacy IdPs** that may not include timestamps
- During **development/testing** with mock IdPs
- You need **maximum compatibility** with various IdP implementations

#### Stricter Security (Enterprise/Production)

For enterprise environments following SAML2Int, configure stricter validation:

```ts title="auth.ts"
sso({
    saml: {
        clockSkew: 60 * 1000,      // 1 minute tolerance
        requireTimestamps: true,   // Reject assertions without timestamps (SAML2Int)
    },
})
```

#### Error Messages

- **"SAML assertion is not yet valid"** — Current time is before the `NotBefore` timestamp (minus clock skew)
- **"SAML assertion has expired"** — Current time is after the `NotOnOrAfter` timestamp (plus clock skew)
- **"SAML assertion missing required timestamp conditions"** — Assertion has no timestamps and `requireTimestamps` is enabled

### Algorithm Validation

Better Auth validates SAML cryptographic algorithms and warns about deprecated ones (SHA-1, RSA 1.5, 3DES) by default.

```ts title="auth.ts"
sso({
    saml: {
        algorithms: {
            // "warn" (default) | "reject" | "allow"
            onDeprecated: "warn",
        },
    },
})
```

| Value | Behavior |
|-------|----------|
| `"warn"` | Log warning, allow authentication (default) |
| `"reject"` | Throw error, block authentication |
| `"allow"` | Silent, no validation |

For strict security (production):

```ts title="auth.ts"
sso({
    saml: {
        algorithms: {
            onDeprecated: "reject",
        },
    },
})
```

#### Supported Algorithms

**Signature algorithms:**
- `RSA-SHA256`, `RSA-SHA384`, `RSA-SHA512`
- `ECDSA-SHA256`, `ECDSA-SHA384`, `ECDSA-SHA512`

**Digest algorithms:**
- `SHA256`, `SHA384`, `SHA512`

**Deprecated (triggers warning/rejection):**
- `RSA-SHA1` (signature)
- `SHA1` (digest)
- `RSA 1.5` (key encryption)
- `3DES` (data encryption)

### Size Limits

Better Auth enforces size limits on SAML payloads to protect against denial-of-service attacks via oversized XML.

| Option | Default | Description |
|--------|---------|-------------|
| `maxResponseSize` | 256KB | Maximum SAML response size in bytes |
| `maxMetadataSize` | 100KB | Maximum IdP metadata size in bytes |

#### Customizing Limits

```ts title="auth.ts"
sso({
    saml: {
        maxResponseSize: 512 * 1024, // 512KB for enterprise IdPs with large group claims
        maxMetadataSize: 100 * 1024, // 100KB
    },
})
```

<Callout type="info">
For true early rejection of oversized payloads (before they reach your application), configure size limits at your infrastructure level (nginx `client_max_body_size`, CDN settings, load balancer).
</Callout>

## Domain verification

Domain verification allows your application to automatically trust a new SSO provider
by automatically validating ownership via the associated domain.

When a provider's domain is verified, it is also trusted for **automatic account linking**. This means that if a user signs in with an SSO provider (OIDC or SAML) and an existing account with the same email exists, the accounts will be linked automatically — as long as the user's email domain matches the provider's verified domain.

<Tabs items={["client", "server"]}>
    <Tab value="client">
```ts title="auth-client.ts"
const authClient = createAuthClient({
    plugins: [
        ssoClient({ // [!code highlight]
            domainVerification: { // [!code highlight]
                enabled: true // [!code highlight]
            } // [!code highlight]
        }) // [!code highlight]
    ]
})
```
    </Tab>

    <Tab value="server">
```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({ // [!code highlight]
            domainVerification: { // [!code highlight]
                enabled: true // [!code highlight]
            } // [!code highlight]
        }) // [!code highlight]
    ]
});
```
    </Tab>
</Tabs>

Once enabled, make sure you migrate the database schema (again).

<Tabs items={["migrate", "generate"]}>
    <Tab value="migrate">
    ```bash
    npx @better-auth/cli migrate
    ```
    </Tab>
    <Tab value="generate">
    ```bash
    npx @better-auth/cli generate
    ```
    </Tab>
</Tabs>

See the [Schema](#if-you-have-enabled-domain-verification) section to add the fields manually.

### Verify your domain

When domain verification is enabled, every new SSO provider will be untrusted at first.
This means that new sign-ups or sign-ins will be allowed until the domain ownership has been verified.

To verify your ownership over a domain, follow these steps:

<Steps>
    <Step>
#### Acquire verification token
When an SSO provider is registered, a **verification token** will be issued to the provider (it will be returned as part of the response).
You can use this token to prove ownership over the domain.
    </Step>
    <Step>
#### Create `TXT` DNS record
To do this, you'll need to add a `TXT` record to your domain's DNS settings:

    *   **Host:** `better-auth-token-{your-provider-id}` (**Note:** This assumes the default token prefix, which can be customized through the `domainVerification.tokenPrefix` option)
    *   **Value:** The verification token you were given.

**Save the record and wait for it to propagate.** This can take up to 48 hours, but it's usually much faster.
    </Step>
    <Step>
#### Submit a validation request
**Once the DNS record has propagated**, you can submit a validation request (See below)
    </Step>
</Steps>

### Domain validation request

Once you have configured your domain, you can use your `auth` instance to submit a validation request.
This request will either result in a rejection (could not prove your ownership over the domain)
or if the verification is successful, your SSO provider domain will be marked as verified.

<APIMethod path="/sso/verify-domain" method="POST" requireSession>
```ts
type verifyDomain = {
  /**
  * The provider id
  */
  providerId: string = "acme-corp"
}
```
</APIMethod>

### Creating a new verification token

Every domain verification token will have a default expiry of 1 week since the moment it was issued
or the moment when the SSO provider was registered.

After that time, the token will expire and cannot longer be used. When that happens,
you can create a new verification token:

<APIMethod path="/sso/request-domain-verification" method="POST" requireSession>
```ts
type requestDomainVerification = {
  /**
  * The provider id
  */
  providerId: string = "acme-corp"
}
```
</APIMethod>

### SAML Endpoints

The plugin automatically creates the following SAML endpoints:

- **SP Metadata**: `/api/auth/sso/saml2/sp/metadata?providerId={providerId}`
- **SAML Callback**: `/api/auth/sso/saml2/callback/{providerId}` (supports both GET and POST)

### SAML Callback URL Configuration

The SAML callback endpoint (`/api/auth/sso/saml2/callback/{providerId}`) handles both **SP-initiated** and **IdP-initiated** SSO flows:

- **SP-initiated**: User clicks "Sign in with SSO" in your app → redirects to IdP → IdP POSTs SAMLResponse to callback
- **IdP-initiated**: User clicks app icon in IdP dashboard (Okta, Azure AD, etc.) → IdP POSTs SAMLResponse to callback

**Important**: The `callbackUrl` in your SAML configuration should point to your application's destination URL (e.g., `/dashboard`), **not** the callback route itself. Better Auth automatically handles the callback route and redirects users to your specified `callbackUrl` after successful authentication.

```ts
samlConfig: {
  callbackUrl: "/dashboard", // Correct - points to your app destination
  // callbackUrl: "/api/auth/sso/saml2/callback/my-provider" // Incorrect - don't point to callback route
}
```

The callback route supports both GET and POST methods automatically, so you don't need to create any additional route handlers in your framework.

## Schema

The plugin requires additional fields in the `ssoProvider` table to store the provider's configuration.

<DatabaseTable
    fields={[
        {
            name: "id", type: "string", description: "A database identifier", isRequired: true, isPrimaryKey: true,
        },
        { name: "issuer", type: "string", description: "The issuer identifier", isRequired: true },
        { name: "domain", type: "string", description: "The domain of the provider", isRequired: true },
        { name: "oidcConfig", type: "string", description: "The OIDC configuration (JSON string)", isRequired: false },
        { name: "samlConfig", type: "string", description: "The SAML configuration (JSON string)", isRequired: false },
        { name: "userId", type: "string", description: "The user ID", isRequired: true, references: { model: "user", field: "id" } },
        { name: "providerId", type: "string", description: "The provider ID. Used to identify a provider and to generate a redirect URL.", isRequired: true, isUnique: true },
        { name: "organizationId", type: "string", description: "The organization Id. If provider is linked to an organization.", isRequired: false }
    ]}
/>

### If you have enabled domain verification:

The `ssoProvider` schema is extended as follows:

<DatabaseTable
    fields={[
        { name: "domainVerified", type: "boolean", description: "A flag indicating whether the provider domain has been verified.", isRequired: false },
    ]}
/>

### IdP-Initiated SAML SSO

Better Auth supports **IdP-initiated SSO flows**, where users access your application directly from their Identity Provider dashboard (e.g., Okta, Azure AD, OneLogin). This is common in enterprise environments where IT admins prefer centralized app access.

**How it works:**

1. User clicks your app icon in the IdP dashboard
2. IdP POSTs SAMLResponse to `/api/auth/sso/saml2/callback/{providerId}`
3. Better Auth processes the assertion, creates a session, and redirects to your `callbackUrl`
4. Browser follows the redirect with a GET request (handled automatically)

**No additional configuration required** - the callback route automatically handles both GET and POST requests.

<Callout type="info">
If you previously created a manual GET handler for the SAML callback route as a workaround, you can remove it after upgrading. Better Auth now handles GET requests automatically.
</Callout>

<Callout type="info">
**Security:** Better Auth validates all redirect URLs to prevent open redirect attacks. Only relative paths (e.g., `/dashboard`) and URLs matching your configured `trustedOrigins` are allowed. Malicious URLs like `https://evil.com` or protocol-relative URLs (`//evil.com`) are automatically blocked.
</Callout>

For a detailed guide on setting up SAML SSO with examples for Okta and testing with DummyIDP, see our [SAML SSO with Okta](/docs/guides/saml-sso-with-okta).

## Options

### Server

**provisionUser**: A custom function to provision a user when they sign in with an SSO provider.

**organizationProvisioning**: Options for provisioning users to an organization.

**defaultOverrideUserInfo**: Override user info with the provider info by default.

**disableImplicitSignUp**: Disable implicit sign up for new users.

If you want to allow account linking for specific trusted providers, enable the `accountLinking` option in your auth config and specify those providers in the `trustedProviders` list.

<TypeTable
  type={{
    provisionUser: {
        description: "A custom function to provision a user when they sign in with an SSO provider.",
        type: "function",
    },
    organizationProvisioning: {
        description: "Options for provisioning users to an organization.",
        type: "object",
        properties: {
            disabled: {
                description: "Disable organization provisioning.",
                type: "boolean",
                default: false,
            },
            defaultRole: {
                description: "The default role for new users.",
                type: "string",
                enum: ["member", "admin"],
                default: "member",
            },
            getRole: {
                description: "A custom function to determine the role for new users.",
                type: "function",
            },
        },
    },
    defaultOverrideUserInfo: {
        description: "Override user info with the provider info by default.",
        type: "boolean",
        default: false,
    },
    disableImplicitSignUp: {
        description: "Disable implicit sign up for new users. When set to true, sign-in needs to be called with requestSignUp as true to create new users.",
        type: "boolean",
        default: false,
    },
    providersLimit: {
        description: "Configure the maximum number of SSO providers a user can register. Set to 0 to disable SSO provider registration.",
        type: "number | function",
        default: 10,
    },
    domainVerification: {
        description: "Configure the domain verification feature",
        type: "object",
        properties: {
            enabled: {
                description: "Enables or disables the domain verification feature",
                type: "boolean",
                required: false
            },
            tokenPrefix: {
                description: "Prefix to append to the verification token identifier",
                type: "string",
                required: false,
                default: "better-auth-token-"
            },
        },
    },
    defaultSSO: {
        description: "Configure a default SSO provider for testing and development. This provider will be used when no matching provider is found in the database.",
        type: "array",
        items: {
            type: "object",
            properties: {
                domain: {
                    description: "The domain to match for this default provider.",
                    type: "string",
                    required: true,
                },
                providerId: {
                    description: "The provider ID to use for the default provider.",
                    type: "string",
                    required: true,
                },
                samlConfig: {
                    description: "SAML configuration for the default provider.",
                    type: "SAMLConfig",
                    required: false,
                },
                oidcConfig: {
                    description: "OIDC configuration for the default provider.",
                    type: "OIDCConfig",
                    required: false,
                },
            }
        },
    },
    saml: {
        description: "SAML security options for AuthnRequest/InResponseTo validation, replay protection, and timestamp handling.",
        type: "object",
        properties: {
            enableInResponseToValidation: {
                description: "Enable InResponseTo validation for SP-initiated SAML flows. Opt-in for backward compatibility.",
                type: "boolean",
                default: false,
            },
            allowIdpInitiated: {
                description: "Allow IdP-initiated SSO (unsolicited SAML responses). Set to false for stricter security. Only applies when validation is enabled.",
                type: "boolean",
                default: true,
            },
            requestTTL: {
                description: "TTL for AuthnRequest records in milliseconds. Only applies when validation is enabled.",
                type: "number",
                default: 300000,
            },
            clockSkew: {
                description: "Clock skew tolerance for SAML assertion timestamp validation (NotBefore/NotOnOrAfter) in milliseconds. Allows for minor time differences between IdP and SP servers.",
                type: "number",
                default: 300000,
            },
            requireTimestamps: {
                description: "Require timestamp conditions (NotBefore/NotOnOrAfter) in SAML assertions. When enabled, assertions without timestamps are rejected. When disabled, they are accepted with a warning logged.",
                type: "boolean",
                default: false,
            },
            algorithms: {
                description: "Algorithm validation options.",
                type: "object",
                properties: {
                    onDeprecated: {
                        description: "Behavior for deprecated algorithms (SHA-1, RSA 1.5, 3DES).",
                        type: "string",
                        enum: ["reject", "warn", "allow"],
                        default: "warn",
                    },
                },
            },
            maxResponseSize: {
                description: "Maximum allowed size for SAML responses in bytes.",
                type: "number",
                default: 262144,
            },
            maxMetadataSize: {
                description: "Maximum allowed size for IdP metadata XML in bytes.",
                type: "number",
                default: 102400,
            },
        },
    },
    modelName: {
        description: "The model name for the SSO provider table",
        type: "string",
        default: "ssoProvider"
    },
    fields: {
        issuer: {
            description: "Custom name for the issuer column",
            type: "string",
            default: "issuer",
        },
		oidcConfig: {
            description: "Custom name for the oidcConfig column",
            type: "string",
            default: "oidcConfig",
        },
		samlConfig: {
            description: "Custom name for the samlConfig column",
            type: "string",
            default: "samlConfig",
        },
		userId: {
            description: "Custom name for the userId column",
            type: "string",
            default: "userId",
        },
		providerId: {
            description: "Custom name for the providerId column",
            type: "string",
            default: "providerId",
        },
		organizationId: {
            description: "Custom name for the organizationId column",
            type: "string",
            default: "organizationId",
        },
		domain: {
            description: "Custom name for the domain column",
            type: "string",
            default: "domain",
        }
    }
  }}
/>
