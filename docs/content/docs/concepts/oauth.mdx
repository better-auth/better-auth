---
title: OAuth
description: How Better Auth handles OAuth
---

Better Auth comes with built-in support for OAuth 2.0 and OpenID Connect. This allows you to authenticate users via popular OAuth providers like Google, Facebook, GitHub, and more.

If your desired provider isn't directly supported, you can use the [Generic OAuth Plugin](/docs/plugins/generic-oauth) for custom integrations.

## Configuring Social Providers

To enable a social provider, you need to provide `clientId` and `clientSecret` for the provider.

Here's an example of how to configure Google as a provider:

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  // Other configurations...
  socialProviders: {
    google: {
      clientId: "YOUR_GOOGLE_CLIENT_ID",
      clientSecret: "YOUR_GOOGLE_CLIENT_SECRET",
    },
  },
});
```

## Usage

### Sign In

To sign in with a social provider, you can use the `signIn.social` function with the `authClient` or `auth.api` for server-side usage.

```ts
await authClient.signIn.social({
  provider: "google", // or any other provider id
})
```

server-side usage:

```ts
await auth.api.signInSocial({
  body: {
    provider: "google", // or any other provider id
  },
});
```

### Link account

To link an account to a social provider, you can use the `linkAccount` function with the `authClient` or `auth.api` for server-side usage.

```ts
await authClient.linkSocial({
  provider: "google", // or any other provider id
})
```

server-side usage:

```ts
await auth.api.linkSocialAccount({
  body: {
    provider: "google", // or any other provider id
  },
  headers: // pass headers with authenticated token
});
```

### Get Access Token

To get the access token for a social provider, you can use the `getAccessToken` function with the `authClient` or `auth.api` for server-side usage. When you use this endpoint, if the access token is expired, it will be refreshed.

```ts
const { accessToken } = await authClient.getAccessToken({
  providerId: "google", // or any other provider id
  accountId: "accountId", // optional, if you want to get the access token for a specific account
})
```

server-side usage:

```ts
await auth.api.getAccessToken({
  body: {
    providerId: "google", // or any other provider id
    accountId: "accountId", // optional, if you want to get the access token for a specific account
    userId: "userId", // optional, if you don't provide headers with authenticated token
  },
  headers: // pass headers with authenticated token
});
```

### Get Account Info Provided by the provider

To get provider specific account info you can use the `accountInfo` function with the `authClient` or `auth.api` for server-side usage.

```ts
const info = await authClient.accountInfo({
  accountId: "accountId", // here you pass in the provider given account id, the provider is automatically detected from the account id
})
```

server-side usage:

```ts
await auth.api.accountInfo({
  body: { accountId: "accountId" },
  headers: // pass headers with authenticated token
});
```

### Requesting Additional Scopes

Sometimes your application may need additional OAuth scopes after the user has already signed up (e.g., for accessing GitHub repositories or Google Drive). Users may not want to grant extensive permissions initially, preferring to start with minimal permissions and grant additional access as needed.

You can request additional scopes by using the `linkSocial` method with the same provider. This will trigger a new OAuth flow that requests the additional scopes while maintaining the existing account connection.

```ts
const requestAdditionalScopes = async () => {
    await authClient.linkSocial({
        provider: "google",
        scopes: ["https://www.googleapis.com/auth/drive.file"],
    });
};
```

<Callout>
Make sure you're running Better Auth version 1.2.7 or later. Earlier versions (like 1.2.2) may show a "Social account already linked" error when trying to link with an existing provider for additional scopes.
</Callout>

### Other Provider Configurations

**scope** The scope of the access request. For example, `email` or `profile`.

**redirectURI** Custom redirect URI for the provider. By default, it uses `/api/auth/callback/${providerName}`.

**disableImplicitSignUp:** Disables implicit sign-up. In order to sign up a user, `requestSignUp` needs to be set to `true` when signing in.

**disableSignUp:** Disables sign-up for new users.

**disableIdTokenSignIn:** Disables the use of the ID token for sign-in. By default, it's enabled for some providers like Google and Apple.

**verifyIdToken** A custom function to verify the ID token.

**getUserInfo** A custom function to fetch user information from the provider. Given the tokens returned from the provider, this function should return the user's information.

**overrideUserInfoOnSignIn**: A boolean value that determines whether to override the user information in the database when signing in. By default, it is set to `false`, meaning that the user information will not be overridden during sign-in. If you want to update the user information every time they sign in, set this to `true`.

**refreshAccessToken**: A custom function to refresh the token. This feature is only supported for built-in social providers (Google, Facebook, GitHub, etc.) and is not currently supported for custom OAuth providers configured through the Generic OAuth Plugin. For built-in providers, you can provide a custom function to refresh the token if needed.

**mapProfileToUser** A custom function to map the user profile returned from the provider to the user object in your database.

Useful, if you have additional fields in your user object you want to populate from the provider's profile. Or if you want to change how by default the user object is mapped.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  // Other configurations...
  socialProviders: {
    google: {
      clientId: "YOUR_GOOGLE_CLIENT_ID",
      clientSecret: "YOUR_GOOGLE_CLIENT_SECRET",
      mapProfileToUser: (profile) => {
        return {
          firstName: profile.given_name,
          lastName: profile.family_name,
        };
      },
    },
  },
});
```

## How OAuth Works in Better Auth

Here's what happens when a user selects a provider to authenticate with:

1. **Configuration Check:** Ensure the necessary provider details (e.g., client ID, secret) are configured.
2. **State Generation:** Generate and save a state token in your database for CSRF protection.
3. **PKCE Support:** If applicable, create a PKCE code challenge and verifier for secure exchanges.
4. **Authorization URL Construction:** Build the provider's authorization URL with parameters like client ID, redirect URI, state, etc. The callback URL usually follows the pattern `/api/auth/callback/${providerName}`.
5. **User Redirection:**
   - If redirection is enabled, users are redirected to the provider's login page.
   - If redirection is disabled, the authorization URL is returned for the client to handle the redirection.

### Post-Login Flow

After the user completes the login process, the provider redirects them back to the callback URL with a code and state. Better Auth handles the rest:

1. **Token Exchange:** The code is exchanged for an access token and user information.
2. **User Handling:**
   - If the user doesn't exist, a new account is created.
   - If the user exists, they are logged in.
   - If the user has multiple accounts across providers, Better Auth links them based on your configuration. Learn more about [account linking](/docs/concepts/users-accounts#account-linking).
3. **Session Creation:** A new session is created for the user.
4. **Redirect:** Users are redirected to the specified URL provided during the initial request or `/`.

If any error occurs during the process, Better Auth handles it and redirects the user to the error URL (if provided) or the callbackURL. And it includes the error message in the query string `?error=...`.

## OAuth State Management

Better Auth provides flexible OAuth state management to handle different deployment scenarios. OAuth state prevents CSRF attacks and stores essential information needed to complete the authentication flow.

### Default Database-Based State Management

By default, Better Auth stores OAuth state in the database for enhanced security. This approach:

- Prevents CSRF attacks through state validation
- Supports PKCE (Proof Key for Code Exchange) for additional security
- Automatically cleans up expired state entries
- Works seamlessly across all OAuth providers

### Custom State Management

For advanced use cases, such as OAuth proxy scenarios or stateless deployments, you can configure custom state management functions:

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import type { OAuthStatePayload } from "better-auth/oauth2/types"

export const auth = betterAuth({
    oauth: {
        stateManagement: {
            generateState: async (context, payload: OAuthStatePayload) => {
                // Example: Simple JSON encoding
                // Note: Real implementations should encrypt or hash the payload for security
                return JSON.stringify(payload);
            },
            parseState: async (context, state: string) => {
                // Example: Simple JSON decoding
                return JSON.parse(state) as OAuthStatePayload;
            }
        }
    }
})
```

### State Management Context

The state management functions receive the following context:

- `context`: The Better Auth endpoint context with access to database, configuration, and request data
- `payload` (generateState): The OAuth state payload containing callback URL, PKCE verifier, and other flow data
- `state` (parseState): The raw state string from the OAuth provider

### Fallback Behavior

If the `stateManagement` configuration is missing, or if either function returns `undefined`, Better Auth automatically falls back to the default database-based approach using the `verification` table.

### Real-World Example: OAuth Proxy with Stateless State

Here's a complete example of implementing stateless state management for an OAuth proxy scenario using the [OAuth Proxy plugin](/docs/plugins/oauth-proxy):

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { oAuthProxy } from "better-auth/plugins"
import { symmetricEncrypt, symmetricDecrypt } from "better-auth/crypto"
import type { OAuthStatePayload } from "better-auth/oauth2/types"

export const auth = betterAuth({
    plugins: [
        oAuthProxy({
            productionURL: "https://my-production-app.com",
            currentURL: "http://localhost:3000",
            oauth: {
                stateManagement: {
                    generateState: async (context, payload: OAuthStatePayload) => {
                        // Encrypt the OAuth payload using Better Auth's crypto utilities
                        return await symmetricEncrypt({
                            key: context.context.options.secret,
                            data: JSON.stringify(payload)
                        });
                    },
                    parseState: async (context, state: string) => {
                        // Decrypt the state using Better Auth's crypto utilities
                        const decrypted = await symmetricDecrypt({
                            key: context.context.options.secret,
                            data: state
                        });

                        return JSON.parse(decrypted) as OAuthStatePayload;
                    }
                }
            }
        })
    ],
    socialProviders: {
        github: {
            clientId: process.env.GITHUB_CLIENT_ID!,
            clientSecret: process.env.GITHUB_CLIENT_SECRET!,
            redirectURI: "https://my-production-app.com/api/auth/callback/github"
        }
    }
})
```

This example demonstrates:

- **Secure encryption** using Better Auth's built-in crypto utilities
- **Simple payload encoding/decoding** without custom fields
- **Uses configured secret** for encryption/decryption
- **Type safety** with proper TypeScript types

<Callout>
This implementation uses the same secret configured for Better Auth, ensuring consistency across your application.
</Callout>

<Callout type="warn">
When using stateless state management, consider the security implications of storing sensitive data in URL parameters.
</Callout>

### CodeVerifier Optimization Strategies

The `codeVerifier` is a critical security component in OAuth PKCE (Proof Key for Code Exchange) flows. It's a 128-character cryptographically secure random string that prevents authorization code interception attacks. However, including the full `codeVerifier` in the OAuth state parameter can significantly increase its size.

Better Auth's state management system provides flexibility for optimizing the `codeVerifier` handling while maintaining full cryptographic strength:

#### Understanding the Optimization Opportunity

When using custom state management, the `generateState` function receives a payload containing an original `codeVerifier` generated by Better Auth. You can choose to:

1. **Use the original `codeVerifier` as-is** - Simplest approach, no optimization
2. **Replace it with a computed value** - Advanced optimization while maintaining security

The key insight is that the `codeVerifier` returned from `generateState` must be the same as the one returned from the corresponding `parseState` call, regardless of how it was generated.

#### Cryptographic Hash-Based Optimization

A common optimization strategy is to compute the `codeVerifier` as a deterministic function of the state value using cryptographic hashing:

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import type { OAuthStatePayload } from "better-auth/oauth2/types"

export const auth = betterAuth({
    oauth: {
        stateManagement: {
            generateState: async (context, payload: OAuthStatePayload) => {
                // Create a short state that can be used to compute the codeVerifier
                const stateValue = `opt-${Date.now()}-${Math.random()}`;

                // Compute codeVerifier as a cryptographically secure hash of the state + salt
                const salt = "your-consistent-salt";
                const computedCodeVerifier = await crypto.subtle.digest('SHA-256',
                    new TextEncoder().encode(stateValue + salt)
                ).then(hash => Array.from(new Uint8Array(hash))
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('')
                    .slice(0, 128)); // Ensure 128 characters

                // Update the payload with the computed codeVerifier
                payload.codeVerifier = computedCodeVerifier;

                return stateValue;
            },
            parseState: async (context, state: string) => {
                // Recompute the same codeVerifier from the state
                const salt = "your-consistent-salt";
                const recomputedCodeVerifier = await crypto.subtle.digest('SHA-256',
                    new TextEncoder().encode(state + salt)
                ).then(hash => Array.from(new Uint8Array(hash))
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('')
                    .slice(0, 128)); // Ensure 128 characters

                return {
                    callbackURL: "/dashboard",
                    codeVerifier: recomputedCodeVerifier,
                    expiresAt: Date.now() + 60000,
                };
            }
        }
    }
})
```

#### Security Considerations

When implementing codeVerifier optimization:

- **Maintain Full Length**: Always ensure the computed `codeVerifier` is exactly 128 characters
- **Use Cryptographically Secure Hashing**: Use SHA-256 or stronger algorithms
- **Include Consistent Salt**: Use a consistent salt value across all environments
- **Avoid Predictable Patterns**: Don't use simple transformations that could be guessed
- **Test Thoroughly**: Ensure the same `codeVerifier` is generated for the same state

#### Benefits of Optimization

This approach provides several benefits:

- **Reduced State Size**: The state parameter becomes much smaller and more manageable
- **Maintained Security**: The `codeVerifier` retains full cryptographic strength
- **Deterministic Generation**: Same state always produces the same `codeVerifier`
- **No External Storage**: No need to store `codeVerifier` separately from the state

#### Alternative Strategies

Other optimization strategies include:

- **Separate Storage**: Store the `codeVerifier` in a separate database table or cache
- **Encrypted State**: Encrypt the entire payload including the original `codeVerifier`
- **Hybrid Approach**: Use a short identifier in state + lookup table for the full `codeVerifier`

<Callout>
The original `codeVerifier` provided by Better Auth is cryptographically secure and can be used as-is if optimization is not needed. Only implement optimization strategies when the benefits outweigh the complexity.
</Callout>

### OAuth State Contents

The OAuth state contains essential information needed to complete the OAuth flow:

```ts
interface OAuthStatePayload {
    callbackURL: string;        // Where to redirect after successful authentication
    codeVerifier: string;       // PKCE code verifier for OAuth 2.0 security
    errorURL?: string;          // Where to redirect on error
    newUserURL?: string;        // Where to redirect for new user signup
    link?: {                    // Account linking information
        email: string;
        userId: string;
    };
    expiresAt: number;          // State expiration timestamp
    requestSignUp?: boolean;    // Whether to request signup
}
```

<Callout>
The `expiresAt` field is validated by Better Auth after parsing your custom state, so you don't need to handle expiration in your `parseState` function.
</Callout>
